#!/usr/bin/python
"""
Script to simulate time-ordered data generated by a CMB experiment
scanning the sky.

Author: Julien Peloton, j.peloton@sussex.ac.uk
"""
from __future__ import division, absolute_import, print_function

import sys
import os

import numpy as np
import healpy as hp
import weave

import detector_pointing
import input_sky

d2r = np.pi / 180.0

class TimeOrderedData():
    """ Class to handle Time-Ordered Data (TOD) """
    def __init__(self, hardware, scanning_strategy, HealpixFitsMap,
                 nside_out=None, width=20.):
        """
        C'est parti!

        Parameters
        ----------
        hardware : hardware instance
            Instance of hardware containing instrument parameters and models.
        scanning_strategy : scanning_strategy instance
            Instance of scanning_strategy containing scan parameters.
        HealpixFitsMap : HealpixFitsMap instance
            Instance of HealpixFitsMap containing input sky parameters.
        nside_out : int, optional
            The resolution for the output maps. Default is nside of the
            input map.
        width : float, optional
            Width for the output map in degree.
        """
        self.hardware = hardware
        self.scanning_strategy = scanning_strategy
        self.HealpixFitsMap = HealpixFitsMap
        if nside_out is None:
            self.nside_out = self.HealpixFitsMap.nside
        else:
            self.nside_out = nside_out

        self.width = width
        self.nsamples = self.scanning_strategy.scan0['nts']
        self.npair = self.hardware.focal_plane.npair
        self.pair_list = np.reshape(
            self.hardware.focal_plane.bolo_index_in_fp, (self.npair, 2))

        ## Pre-compute boresight pointing objects
        self.prepare_boresightpointing()

        ## Polarisation angles: intrinsic and HWP angles
        self.get_angles()

        ## Position of bolometers in the focal plane
        ## TODO move that elsewhere...
        self.ypos = self.hardware.beam_model.ypos
        self.xpos = self.hardware.beam_model.xpos
        self.xpos = self.xpos / np.cos(self.ypos)

        ## Initialise pointing matrix, that is the matrix to go from time
        ## to map domain, for all pairs of detectors.
        self.point_matrix = np.zeros(
            (self.npair, self.nsamples), dtype=np.int32)

        ## Initialise the mask for timestreams
        self.wafermask_pixel = self.get_timestream_masks()

        ## Get observed pixels
        self.obspix, self.npixsky = self.get_obspix(
            self.width,
            self.scanning_strategy.ra_mid,
            self.scanning_strategy.dec_mid)

        ## Get timestream weights
        self.sum_weight, self.diff_weight = self.get_weights()

        ## Initialise sky maps
        self.initialise_sky_maps()

    def initialise_sky_maps(self):
        """
        Create empty sky maps. This includes:
        * d : projected weighted sum of timestreams
        * dc : projected noise weighted difference of timestreams
            multiplied by cosine
        * ds : projected noise weighted difference of timestreams
            multiplied by sine
        * nhit : projected hit counts.
        * w : projected (inverse) noise weights and hits.
        * cc : projected noise weighted cosine**2
        * ss : projected noise weighted sine**2
        * cs : projected noise weighted cosine * sine.

        """
        # To accumulate A^T N^-1 d
        self.d = np.zeros(self.npixsky)
        self.dc = np.zeros(self.npixsky)
        self.ds = np.zeros(self.npixsky)

        # To accumulate A^T N^-1 A
        self.w = np.zeros(self.npixsky)
        self.cc = np.zeros(self.npixsky)
        self.cs = np.zeros(self.npixsky)
        self.ss = np.zeros(self.npixsky)

        self.nhit = np.zeros(self.npixsky, dtype=np.int32)

    def get_angles(self):
        """
        Retrieve polarisation angles: intrinsic (focal plane) and HWP angles,
        and initialise total polarisation angle.
        """
        self.hwpangle = self.hardware.half_wave_plate.compute_HWP_angles(
            sample_rate=self.scanning_strategy.scan0['sample_rate'],
            size=self.nsamples)

        self.intrinsic_polangle = self.hardware.focal_plane.bolo_polangle

        ## Will contain the total polarisation angles for all bolometers
        ## That is PA + intrinsic + 2 * HWP
        self.pol_angs = np.zeros((self.npair, self.nsamples))

    def get_timestream_masks(self):
        """
        Define the masks for all the timestreams.
        1 if the time sample should be included, 0 otherwise.
        Set to ones for the moment.
        """
        return np.ones((self.npair, self.nsamples), dtype=int)

    def get_obspix(self, width, ra_src, dec_src):
        """
        Return the index of observed pixels within a given patch
        defined by (`ra_src`, `dec_src`) and `width`.
        This will be the sky patch that will be returned.

        Parameters
        ----------
        width : float
            Width of the patch in degree.
        ra_src : float
            RA of the center of the patch in degree.
        dec_src : float
            Dec of the center of the patch in degree.
        """
        ## Change to radian
        ra_src = ra_src * d2r
        dec_src = dec_src * d2r
        ## TODO implement the first line correctly...
        try:
            xmin, xmax, ymin, ymax = np.array(width) * d2r
        except TypeError:
            xmin = xmax = ymin = ymax = d2r * width / 2.

        # If map bound crosses zero make coordinates
        ## bounds monotonic in [-pi,pi]
        ra_min = (ra_src - xmin)
        if (ra_src + xmax) >= 2 * np.pi:
            ra_max = (ra_src + xmax) % (2 * np.pi)
            ra_min = ra_min if ra_min <= np.pi else ra_min - 2 * np.pi
        else:
            ra_min = (ra_src - xmin)
            ra_max = (ra_src + xmax)

        dec_min = max([(dec_src - ymin), -np.pi/2])
        dec_max = min([dec_src + ymax, np.pi/2])

        obspix = input_sky.get_obspix(ra_min, ra_max,
                                      dec_min, dec_max,
                                      self.nside_out)
        npixsky = len(obspix)

        return obspix, npixsky

    def get_weights(self):
        """
        Return the noise weights of the sum and difference timestreams
        (in 1/noise units).
        For the moment, there is one number per pair for the whole scan.
        Typically, this can be the (mean) PSD of the timestream.

        Default for the moment is 1 (i.e. no weights).

        Returns
        ----------
        sum_weight : 1d array
            Weights for the sum of timestreams (size: npair)
        diff_weight : 1d array
            Weights for the difference of timestreams (size: npair)
        """
        return np.ones((2, self.npair), dtype=int)

    def prepare_boresightpointing(self):
        """
        Prepare the boresight pointing for all the focal plane bolometers.
        The actual pointing (RA/Dec/Parallactic angle) is computed on-the-fly
        when we load the data.

        Parameters
        ----------
        ut1utc_fn : string
            File containing time correction to UTC.
        """
        lat = float(
            self.scanning_strategy.telescope_location.lat) * 180. / np.pi

        self.pointing = detector_pointing.pointing(
            az_enc=self.scanning_strategy.scan0['azimuth'],
            el_enc=self.scanning_strategy.scan0['elevation'],
            time=self.scanning_strategy.scan0['clock-utc'],
            value_params=self.hardware.pointing_model.value_params,
            allowed_params=self.hardware.pointing_model.allowed_params,
            ut1utc_fn=self.scanning_strategy.ut1utc_fn,
            lat=lat)

    def compute_simpolangle(self, ch, parallactic_angle, do_demodulation=False,
                            polangle_err=False):
        """
        Compute the full polarisation angles used to generate timestreams.
        The polarisation angle contains intrinsic polarisation angle (from
        focal plane design), parallactic angle (from pointing), and the angle
        from the half-wave plate.

        Parameters
        ----------
        ch : int
            Channel index in the focal plane.
        parallactic_angle : 1d array
            All parallactic angles for detector ch.
        do_demodulation : bool, optional
            If True, use the convention for the demodulation (extra minus sign)
        polangle_err : bool, optional
            If True, inject systematic effect.
            TODO: remove that in the systematic module.

        Returns
        ----------
        pol_ang : 1d array
            Vector containing the values of the polarisation angle for the
            whole scan.

        Examples
        ----------
        >>> inst, scan, sky_in = load_fake_instrument()
        >>> tod = TimeOrderedData(inst, scan, sky_in)
        >>> print(tod.compute_simpolangle(0,
        ...     np.array([np.pi] * scan.scan0['nts']))[:4])
        [  0.          25.13274123  50.26548246  75.39822369]
        """
        if not polangle_err:
            ang_pix = (90.0 - self.intrinsic_polangle[ch]) * d2r
            if not do_demodulation:
                pol_ang = parallactic_angle + ang_pix + 2.0 * self.hwpangle
            else:
                pol_ang = parallactic_angle - ang_pix - 2.0 * self.hwpangle
        else:
            print("This is where you call the systematic module!")
            sys.exit()
            pass

        return pol_ang

    def map2tod(self, ch):
        """
        Scan the input sky maps to generate timestream for channel ch.

        Parameters
        ----------
        ch : int
            Channel index in the focal plane.

        Examples
        ----------
        >>> inst, scan, sky_in = load_fake_instrument()
        >>> tod = TimeOrderedData(inst, scan, sky_in)
        >>> d = tod.map2tod(0)
        >>> print(d[:10]) #doctest: +NORMALIZE_WHITESPACE
        [  77.14047019   77.1380591    77.13568942   77.13336348   77.13108377
           77.12885305  -61.4004047   120.05901259  120.06668205  120.07449681]
        """
        ## Use bolometer beam offsets.
        azd, eld = self.xpos[ch], self.ypos[ch]

        ## Compute pointing for detector ch
        ra, dec, pa = self.pointing.offset_detector(azd, eld)

        ## Retrieve corresponding pixels on the sky, and their index locally.
        pixnum, loc_pix = mapindex1d(
            self.obspix, ra, dec, self.nside_out,
            cut_outliers=True, ext_map_gal=self.HealpixFitsMap.ext_map_gal)

        ## Store list of hit pixels only for top bolometers
        if ch % 2 == 0:
            self.point_matrix[int(ch/2)] = loc_pix

        ## Gain mode. Not yet implemented, but this is the place!
        norm = 1.0

        if self.HealpixFitsMap.do_pol:
            pol_ang = self.compute_simpolangle(ch, pa,
                                               do_demodulation=False,
                                               polangle_err=False)

            ## Store list polangle only for top bolometers
            if ch % 2 == 0:
                self.pol_angs[int(ch/2)] = pol_ang

            return (self.HealpixFitsMap.I[pixnum] +
                    self.HealpixFitsMap.Q[pixnum] * np.cos(2 * pol_ang) +
                    self.HealpixFitsMap.U[pixnum] * np.sin(2 * pol_ang)) * norm
        else:
            return norm * self.HealpixFitsMap.I[pixnum]

    def tod2map_alldet(self, waferts, language='fortran'):
        """
        Project time-ordered data into sky maps.
        """
        '''
        Coadd timestream data in to a map
        '''
        nchwedge = waferts.shape[0]
        npixfp = nchwedge / 2
        nt = int(waferts.shape[1])
        nces = 1

        ## Check sizes
        assert npixfp == self.point_matrix.shape[0]
        assert nt == self.point_matrix.shape[1]

        assert npixfp == self.pol_angs.shape[0]
        assert nt == self.pol_angs.shape[1]

        assert npixfp == self.diff_weight.shape[0]
        assert npixfp == self.sum_weight.shape[0]

        d, w, nhit, dc, ds, cc, cs, ss = \
            self.d, self.w, self.nhit, self.dc, \
            self.ds, self.cc, self.cs, self.ss

        waferi1d = self.point_matrix.flatten()
        waferpa = self.pol_angs.flatten()
        waferts = waferts.flatten()
        diff_weight = self.diff_weight.flatten()
        sum_weight = self.sum_weight.flatten()
        wafermask_pixel = self.wafermask_pixel.flatten()
        wafermask_pixel = np.array(wafermask_pixel, dtype=int)

        from tod_f import tod_f
        ## /!\ npixfp = focal plane pixel, self.npixsky = sky pixel
        tod_f.tod2map_alldet_f(d, w, dc, ds, cc, cs, ss, nhit,
                               waferi1d, waferpa, waferts,
                               diff_weight, sum_weight, nt,
                               wafermask_pixel, npixfp, self.npixsky)
        # Garbage collector guard
        wafermask_pixel

def mapindex1d(obspix, ra, dec, nside, cut_outliers=True, ext_map_gal=False):
    """
    Convert projected x,y coordinates to integer index into a flat map vector
    """
    npixsky = len(obspix)
    theta = np.pi / 2 - dec
    phi = ra
    if ext_map_gal:
        r = hp.Rotator(coord=['C', 'G'])
        theta, phi = r(theta, phi)

    i1d = hp.ang2pix(nside, theta, phi)
    idxs = obspix.searchsorted(i1d)
    mask1 = idxs < npixsky
    loc = mask1
    loc[mask1] = obspix[idxs[mask1]] == i1d[mask1]
    outside_pixels = np.invert(loc)
    if (np.sum(outside_pixels) and (not cut_outliers)):
        raise ValueError(
            "Pixels outside patch boundaries. Patch width insufficient")
    else:
        idxs[outside_pixels] = -1
    return i1d, idxs

def load_fake_instrument():
    """
    For test purposes.
    """
    sys.path.insert(0, os.path.realpath(os.path.join(os.getcwd(), '.')))
    sys.path.insert(
        0,
        os.path.realpath(os.path.join(os.getcwd(), 's4cmb')))
    from input_sky import HealpixFitsMap
    from input_sky import create_sky_map, write_healpix_cmbmap
    from instrument import hardware
    from scanning_strategy import scanning_strategy
    ## Create a fake input
    sky = create_sky_map('s4cmb/data/test_data_set_lensedCls.dat', nside=16)
    write_healpix_cmbmap(output_filename='mymaps.fits', data=sky, nside=16)
    sky_in = HealpixFitsMap('mymaps.fits', do_pol=True,
                            verbose=False, no_ileak=False, no_quleak=False)
    ## Initialise our instrument
    ## Generate a focal plane with 4 Crate boards, each with 1 MUX board,
    ## each with 1 Squid, each with 16 pairs of bolometers.
    ## The focal plane is 60 cm wide (square),
    ## and each detector beam is Gaussian with FWHM of 3.5 arcmin.
    inst = hardware(ncrate=1, ndfmux_per_crate=1,
                    nsquid_per_mux=1, npair_per_squid=4,
                    fp_size=60., FWHM=3.5,
                    beam_seed=58347, projected_fp_size=3., pm_name='5params',
                    type_HWP='CRHWP', freq_HWP=2., angle_HWP=0., debug=False)
    ## Initialize our scanning strategy
    scan = scanning_strategy(nCES=1, start_date='2013/1/1 00:00:00',
                             telescope_longitude='-67:46.816',
                             telescope_latitude='-22:56.396',
                             telescope_elevation=5200.,
                             name_strategy='deep_patch',
                             sampling_freq=1., sky_speed=0.4,
                             language='python')
    scan.run()

    return inst, scan, sky_in


if __name__ == "__main__":
    import doctest
    doctest.testmod()
